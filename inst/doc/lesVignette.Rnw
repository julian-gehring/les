%% LyX 1.6.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}

\usepackage[unicode=true, pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%\VignetteIndexEntry{Detection of Loci of Enhanced Significance (LES) in tiling array data with the les package}
%\VignettePackage{les}

\usepackage{fancyvrb}
\fvset{listparameters={\setlength{\topsep}{0pt}}}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\makeatother

\begin{document}

\title{Introduction to the les package:\\
Loci of Enhanced Significance in Tiling Array Data}


\author{Julian Gehring}
\maketitle
\begin{abstract}
In this vignette we describe using the les package for finding Loci
of Enhanced Significance (LES) in tiling microarray data. With an
example of a general framework we illustrate how to apply the package
for exploring regions of regulation in differential expression and
chip-CHIP analysis.
\end{abstract}

\section{Introduction}

Tiling microarrays have become an important platform for the investigation
of regulation in expression and DNA-protein interaction. They provide
a relatively unbiased tool covering large regions of interest in the
genome.

Beside the analysis of single microarrays the investigation of differential
effects between experimental conditions is critical for current research.
A common approach consists in applying statistical tests on the level
of single probes and thereby computing p-values for each probe independently.
Since the targets of such experiments cover areas with several probes
the logical next step involves combining information from neighboring
probes into a reasonable statistic. In regions with differential effects
the test statistics change their distribution and are referred to
as Loci of Enhanced Significance (LES). The changes in the test statistics
depend on the underlying test applied.

The les package provides the ability to detect such LES independent
of the underlying statistical test and can therefore be used for a
wide range of applications. This vignette illustrates how to LES can
be found in tiling microarray data sets.

<<echo=false>>=
options(width=70)
@


\section{Data and statistics on probe level}

For this analysis we will use a simulated data set describing differential
expression between two conditions. It contains 1000 probes with 3
chips each for the conditions treatment and control. The expression
values are stored in an expression set. We will extract the position
of the probes, the conditions of the samples and the expression values.
There are two regions with changes present in the data, each being
50 bp long.

<<loadData>>=
library(les)
library(Biobase)
data(simTile)
treatment <- as.factor(phenoData(simTile)$condition == "treatment")
pos <- featureData(simTile)$position
exprs <- exprs(simTile)
regions <- c(100, 150, 600, 650)
cols <- rep(c("lightblue3", "lightgreen"), each=2)
@

Next we have a look at the expression values.

<<plotExpressionValues, fig=TRUE, echo=TRUE>>=
matplot(exprs, pch=".", xlab="Probe position", ylab="Expression")
abline(v=regions, col=cols)
@

In the next step we will compute the statistics of changes between
the two conditions for each probe. Since the sample size as for most
tiling microarray experiments is small we will use a modified t-test
provided by the limma package.

We will also plot the p-values against the probe positions. By looking
at the raw p-values it may be hard to detect the LES.

<<estimateProbeLevelStatistics>>=
library(limma)
design <- cbind(mean=1, diff=treatment)
fit <- lmFit(exprs, design)
fit <- eBayes(fit)
pval <- as.numeric(fit$p.value[, "diff"])
@

<<plotProbeLevelStatistics, fig=TRUE, echo=TRUE>>=
plot(pos, pval, pch=20, xlab="Probe position", ylab="P-value")
abline(v=regions, col=cols)
@


\section{Incorporation information from neighboring p-values to find LES}

In any well designed tiling array experiments the potential targets
will cover several neighboring probes. Thereby neighboring p-values
should contain mutual information and incorporation of such will be
beneficial.

In the les package this in done in the following manner: For each
probe $i$ the the surrounding p-values get weights assigned by some
windowing function. A weighted cumulative density is then computed
and the fraction of significant p-values is estimated by iterative
linear fitting. The method is based on the fact that p-values under
the null hypothesis $H_{0}$ are from a uniform distribution whereas
p-values violating $H_{0}$ are shifted towards smaller values. This
results in the index $\Lambda_{i}$ which measures the fraction of
p-values violating $H_{0}$ and therefore the degree of regulation
in the local surrounding. It should be noted that this approach is
closely related to the estimation of a false discovery rate and $\Lambda_{i}$
can be interpreted as locally weighted version of such.

For the analysis we will first pass our data to an object of class
Les. The only data required are the position of the probes, the corresponding
p-values from the statistical test and optionally their chromosomal
location.

Then we can compute our first estimate of $\Lambda_{i}$ for which
we have to specify a window size. The power of the detection will
be maximal if the size of the window matches the size of the target.
In many experiments one has a rough prior knowledge on the target
size which will be sufficient of the first step. Later we will discuss
an approach the estimate the optimal window size from the data itself.
Here we will chose a small window size to start with.

<<createLes>>=
res <- create(pos, pval)
@

By default a triangular weighting function will be chosen. We can
also take a rectangular window or write our own function and pass
it via the weighting argument. We can further on specify whether we
want to include the Grenander correction for the cumulative density
or use multicore processing on some platforms.

<<estimateLes>>=
win <- 30
res <- estimate(res, win)
@

All data, results and parameters are stored in the object which is
in our case called res. We can get a short summary on the results
by calling res or by plotting it.

<<showPlotLes, fig=TRUE, echo=TRUE>>=
res
plot(res)
abline(v=regions, col=cols)
@

For comparison we will analyze and plot the same data with a different
window size. This allows us to explore our data set.

<<estimateLes2>>=
win2 <- 50
res <- estimate(res, win2)
@

<<showPlotLes2, fig=TRUE, echo=TRUE>>=
res
plot(res)
abline(v=regions, col=cols)
@

We can already see two distinct peaks that correspond to the regions
of simulated regulation.


\section{Parameter estimation from the data}

To turn the continuous $\Lambda_{i}$ into regions of interest we
have to define a threshold $\Theta$. It can be derived from the data
by estimating the number of probes with a significant effect $R$
on the whole array. Then $\Theta$ can be chosen such that $\mid\Lambda_{i}\geq\Theta\mid=R$.
The content of any slot can be accessed by using the {[} function.

<<cutoff>>=
res <- cutoff(res, grenander=TRUE, verbose=TRUE)
res["nSigProbes"]
@

Based on $\Theta$ we can search for regions that have a continuous
$\Lambda_{i}\geq\Theta$. The regions function takes by default the
estimated $\hat{\Theta}$ as shown before. We can also pass our own
$\Theta$. Further restrictions can be imposed on the regions search
such as the minimal length of a region and the maximum gap allowed
between probes of one region.

<<regions>>=
theta <- 0.3
res <- regions(res, limit=theta)
res["regions"]
@

The optimal window for a region can be estimated using a leave-one-out
cross validation. This approach can be used to optimize the window
size parameter for each region seperately in a second step.

<<chi2, fig=FALSE, echo=TRUE>>=
winSize <- seq(10, 100, by=10)
reg2 <- matrix(c(500, 700), nrow=1)
#chi2 <- optimalKernel(res, winSize, reg2)
#plot(winSize, chi2, type="b")
@


\section{Calculation of confidence intervals}

In some cases it is also useful to provide confidence (CI) intervals
for $\Lambda_{i}$. These are computed by bootstrapping the probes
in the window. Since bootstrapping is by its nature computationally
demanding and CI are primarily interesting in regions of interest
it it possible to compute CI for a subset of probes.

<<ci>>=
subset <- pos >= 580 & pos <= 670
#res <- ci(res, subset)
@

<<plotCi, fig=TRUE, echo=TRUE>>=
#plot(res, error="ci", limit=theta, xlim=c(580, 670))
@

The two RDEs can clearly be detected.\\
Now look at the second RDE and plot also the 0.95 CIs.


\section{Specification of own window functions}

With the triangWeight and rectangWeight two window functions are already
include in the les package. We can also specifiy own window functions
and pass it via the weighting argument in the estimate function. The
have to be given in the following format:

<<weightFcn>>=
weightFcn <- function(distance, win)  {
weight <- 1 - distance/weight
return(weight)
}
@


\section{References}

\newpage{}

\appendix

\section{Session information}

<<sessionInfo>>=
sessionInfo()
@
\end{document}
